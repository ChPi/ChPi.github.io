---
layout:     post
title:      "Java基础「1」"
subtitle:   " HashMap vs ConcurrentHashMap vs HashTable"
date:       2017-02-16
author:     "Jie"
header-img: "img/post-bg-scala-version.jpg"
tags:
    - Java
---

> 线程安全

## HashMap

> 初始化
```
//jdk1.8
this.loadFactor = loadFactor;
this.threshold = tableSizeFor(initialCapacity);
// jdk1.7
this.loadFactor = loadFactor;
threshold = initialCapacity;
```
1.8阈值都是2的平方，而且1.8桶里面会进化为红黑树，1.7一直是链表。

HashMap不是线程安全，会导致数据不一致和死循环(resize)。

## ConcurrentHashMap

> LOAD_FACTOR 写死了,
  使用unsafe直接读写既提高效率，也是原子操作，保证线程安全。

put的时候每个桶一个锁。

但是当桶为空的时候，没有加锁，这时候如果多线程，并且多个key分到这个桶，线程不安全？

```
 else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
                if (casTabAt(tab, i, null,
                             new Node<K,V>(hash, key, value, null)))
                    break;                   // no lock when adding to empty bin
            }
```
> https://en.wikipedia.org/wiki/Compare-and-swap
CAS是硬件层面的原子操作，其实还是安全。

**扩容的时候死循环？**

扩容分两步，生产新的容器和移动元素。

只能有一个线程对容器扩容，但是可以多个线程转移元素。

```
private final void addCount(long x, int check) {
        CounterCell[] as; long b, s;
        if ((as = counterCells) != null ||
            !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {
            CounterCell a; long v; int m;
            boolean uncontended = true;
            if (as == null || (m = as.length - 1) < 0 ||
                (a = as[ThreadLocalRandom.getProbe() & m]) == null ||
                !(uncontended =
                  U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {
                fullAddCount(x, uncontended);
                return;
            }
            if (check <= 1)
                return;
            s = sumCount();
        }
        if (check >= 0) {
            Node<K,V>[] tab, nt; int n, sc;
            while (s >= (long)(sc = sizeCtl) && (tab = table) != null &&
                   (n = tab.length) < MAXIMUM_CAPACITY) {
                int rs = resizeStamp(n);
                if (sc < 0) {
                    if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                        sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                        transferIndex <= 0)
                        break;
                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                        transfer(tab, nt);
                }
                else if (U.compareAndSwapInt(this, SIZECTL, sc,
                                             (rs << RESIZE_STAMP_SHIFT) + 2))
                    transfer(tab, null);
                s = sumCount();
            }
        }
    }
```

**所以只需要注意程序的线程安全**

下面这种可能就不是想要的结果
```
if (!map.containsKey(key))
   return map.put(key, value);
else
   return map.get(key);
```




